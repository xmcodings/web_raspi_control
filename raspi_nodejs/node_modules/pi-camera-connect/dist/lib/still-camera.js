"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const si = require("systeminformation");
const __1 = require("..");
const util_1 = require("../util");
const shared_args_1 = require("./shared-args");
class StillCamera {
    constructor(options = {}) {
        this.options = Object.assign({ rotation: __1.Rotation.Rotate0, flip: __1.Flip.None, delay: 1 }, options);
    }
    static async getJpegSignature() {
        const systemInfo = await si.system();
        switch (systemInfo.model) {
            case 'BCM2711':
            case 'BCM2835 - Pi 3 Model B':
            case 'BCM2835 - Pi 3 Model B+':
            case 'BCM2835 - Pi 4 Model B':
            case 'BCM2835 - Pi Zero':
            case 'BCM2835 - Pi Zero W':
                return Buffer.from([0xff, 0xd8, 0xff, 0xe1]);
            default:
                throw new Error(`Could not determine JPEG signature. Unknown system model '${systemInfo.model}'`);
        }
    }
    async takeImage() {
        try {
            return await util_1.spawnPromise('raspistill', [
                /**
                 * Add the command-line arguments that are common to both `raspivid` and `raspistill`
                 */
                ...shared_args_1.getSharedArgs(this.options),
                /**
                 * Capture delay (ms)
                 */
                '--timeout',
                this.options.delay.toString(),
                /**
                 * Do not display preview overlay on screen
                 */
                '--nopreview',
                /**
                 * Output to stdout
                 */
                '--output',
                '-',
            ]);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                throw new Error("Could not take image with StillCamera. Are you running on a Raspberry Pi with 'raspistill' installed?");
            }
            throw err;
        }
    }
}
exports.default = StillCamera;
//# sourceMappingURL=still-camera.js.map